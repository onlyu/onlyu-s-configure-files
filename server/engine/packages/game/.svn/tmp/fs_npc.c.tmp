#include "fs_npc.h"
#include "fs_hlist.h"
#include "fs_mem_pool.h"
#include "fs_common.h"
#include "fs_lpc_op.h"
#include "fs_log.h"
#include "fs_char_ob.h"
#include "fs_rpc_c.h"
#include "fs_scene.h"
#include "fs_aoi.h"

void fs_sys_init_npc_module(int max, int startid, int endid)
{
	fs_init_char_ob(T_CHAR_NPC, max, sizeof(fs_npc_object_t), startid, endid);
}

inline void _init_npc(fs_npc_object_t *nob, int npcid)
{
	nob->aoi_area_r = 0;
	nob->visible = 0;
	nob->is_effect_npc = 0;
	nob->status = 0;
	nob->status_sec = 0;
	nob->status_tar = 0;
	nob->iFighting = 0;
	nob->start_walk_msec = 0;
	nob->walk_msec = 0;
	nob->is_walk = 0;
	nob->to_x = 0;
	nob->to_y = 0;
	nob->to_z = 0;
	fs_init_scene_entry(&nob->entry, T_ENTRY_NPC, npcid, nob);
}

// 新建物品
int fs_new_npc(char *path)
{
	fs_char_ob_t *cob;
	fs_lpc_object_t *oob;

	cob = fs_new_char_ob(T_CHAR_NPC, path, NULL);

	if (cob) {
		oob = CHAR_OB_ORIG_OB(cob);
		// 初始化
		_init_npc((fs_npc_object_t *) CHAR_OB_ENTRY(cob), CHAR_OB_ID(cob));
		/* 物品初始化接口 */
		call_object_func(oob->ob, "InitNpc", "i", CHAR_OB_ID(cob));

		return CHAR_OB_ID(cob);
	}
	return 0;
}

// 根据信息生成物品
// type : 物品type
// m    : 存盘数据
//
// 调用函数不需要free_maping(m)
int fs_restore_npc(char *path, mapping_t *m)
{
	fs_char_ob_t * cob;
	fs_lpc_object_t * oob;

	cob = fs_new_char_ob(T_CHAR_NPC, path, m);

	if (cob) {
		/* 物品初始化接口 */
		oob = CHAR_OB_ORIG_OB(cob);
		_init_npc((fs_npc_object_t *) CHAR_OB_ENTRY(cob), CHAR_OB_ID(cob));
		call_object_func(oob->ob, "InitItem", "i", CHAR_OB_ID(cob));
		return CHAR_OB_ID(cob);
	}
	return 0;
}

void fs_destroy_npc(int npcid)
{
	fs_npc_leave_scene(npcid);
	fs_free_char_ob(T_CHAR_NPC, npcid);
}

inline fs_scene_entry_t *fs_find_npc_entry(int npcid)
{
	fs_char_ob_t *cob;
	fs_npc_object_t *nob;

	cob = fs_find_char_ob(T_CHAR_NPC, npcid);
	if (cob) {
		nob = (fs_npc_object_t *) CHAR_OB_ENTRY(cob);
		return &nob->entry;
	}
	return NULL;
}

inline fs_npc_object_t *fs_npc_object(int npcid)
{
	fs_char_ob_t *cob;

	cob = fs_find_char_ob(T_CHAR_NPC, npcid);
	if (cob) {
		return (fs_npc_object_t *) CHAR_OB_ENTRY(cob);
	}
	return NULL;
}

int is_npc_online(int npcid)
{
	fs_char_ob_t *cob;
	cob = fs_find_char_ob(T_CHAR_NPC, npcid);
	if (cob) {
		return 1;
	}
	return 0;
}

object_t *get_npc_lpcob(int npcid)
{
	fs_char_ob_t *cob;

	cob = fs_find_char_ob(T_CHAR_NPC, npcid);
	if (cob) {
		return ((fs_lpc_object_t *) CHAR_OB_ORIG_OB(cob))->ob;
	}
	return NULL;

}

// 取NPC身上的变量
svalue_t * get_npc_prop(int npcid, svalue_t *key)
{
	return fs_get_temp_map(T_CHAR_NPC, npcid, key);
}

mapping_t *fs_get_npc_map(int npcid, int saved)
{
	fs_char_ob_t * cob;
	cob = fs_find_char_ob(T_CHAR_NPC, npcid);
	if (!cob) {
		return NULL;
	}
	if (saved) {
		return cob->save_map;
	} else {
		return cob->temp_map;
	}
}

void fs_set_npc_map(int npcid, mapping_t *m, int saved)
{
	fs_char_ob_t * cob;
	cob = fs_find_char_ob(T_CHAR_NPC, npcid);
	if (!cob) {
		return;
	}
	if (saved) {
		if (cob->save_map) {
			free_mapping(cob->save_map);
		}
		cob->save_map = m;
		add_ref(m, "set npc map");
	} else {
		if (cob->temp_map) {
			free_mapping(cob->temp_map);
		}
		cob->temp_map = m;
		add_ref(m, "set npc map");
	}
}

//========================================================
// rpc

// 点击NPC

void rpc_server_click_npc(int uid, msg_click_npc_s *click_info)
{
	fs_char_ob_t *cob;
	// object_t *ob;

	cob = fs_find_char_ob(T_CHAR_NPC, click_info->npcnum);

	if (cob) {
		// ob = ((fs_lpc_object_t *) CHAR_OB_ORIG_OB(cob))->ob;
		call_script_func("module/scene/npc.c", "do_click_npc", "ii", uid, click_info->npcnum);
	}
}

//========================================================
// efun

#define  SET_PERM_VAR { \
	SET_ALL_ARGS \
	fs_set_save_map(T_CHAR_NPC, ARGS(0)->u.number, ARGS(1), ARGS(2)); \
	POP_ALL_ARGS \
}

#define GET_PERM_VAR { \
	SET_ALL_ARGS \
	svalue_t *v = fs_get_save_map(T_CHAR_NPC, ARGS(0)->u.number, ARGS(1)); \
	POP_ALL_ARGS \
	push_svalue(v); \
}

#define  SET_TEMP_VAR { \
	SET_ALL_ARGS \
	fs_set_temp_map(T_CHAR_NPC, ARGS(0)->u.number, ARGS(1), ARGS(2)); \
	POP_ALL_ARGS \
}

#define GET_TEMP_VAR { \
	SET_ALL_ARGS \
	svalue_t *v = fs_get_temp_map(T_CHAR_NPC, ARGS(0)->u.number, ARGS(1)); \
	POP_ALL_ARGS \
	push_svalue(v); \
}

void f_new_npc(void)
{
	SET_ALL_ARGS
	int npcid = fs_new_npc(ARGS(0)->u.string);
	POP_ALL_ARGS

	push_number(npcid);
}

void f_restore_npc(void)
{
	SET_ALL_ARGS
	int npc = fs_restore_npc(ARGS(0)->u.string, ARGS(1)->u.map);
	POP_ALL_ARGS

	push_number(npc);
}

void f_SetNpc(void)
{
	SET_TEMP_VAR
}

void f_GetNpc(void)
{
	GET_TEMP_VAR
}

void f_SetNpcSave(void)
{
	SET_PERM_VAR
}

void f_GetNpcSave(void)
{
	GET_PERM_VAR
}


void f_destroy_npc(void)
{
	SET_ALL_ARGS
	fs_destroy_npc(ARGS(0)->u.number);
	POP_ALL_ARGS
}

void f_get_npc_object(void)
{
	SET_ALL_ARGS
	fs_char_ob_t *cob;
	cob = fs_find_char_ob(T_CHAR_NPC, ARGS(0)->u.number);
	POP_ALL_ARGS
	if (cob && cob->oob && cob->oob->ob) {
		push_object(cob->oob->ob);
	} else {
		push_svalue(&const0u);
	}
}

void f_get_npc_pos(void)
{
	SET_ALL_ARGS
	fs_scene_entry_t * entry;
	array_t * v; 
	entry = fs_find_npc_entry(ARGS(0)->u.number);
	POP_ALL_ARGS
	if (entry) {
		int x = 0, y = 0;
		get_entry_npc_pos(entry, &x, &y);
		v = allocate_empty_array(3); 
		v->item[0].type = T_NUMBER;                                                                                                                                                                      
		v->item[1].type = T_NUMBER;                                                                                                                                                                      
		v->item[2].type = T_NUMBER;                                                                                                                                                                      
		v->item[0].u.number = entry->z;                                                                                                                                                                         
		v->item[1].u.number = x;
		v->item[2].u.number = y;
		push_refed_array(v);
		return;
	}
	push_svalue(&const0u);
}

// ========================================================
// NPC aoi事件

void f_set_npc_circle_field(void)
{
	SET_ALL_ARGS
	fs_npc_object_t *nob;
	int npcid = ARGS(0)->u.number;
	int r = ARGS(1)->u.number;

	POP_ALL_ARGS

	nob = fs_npc_object(npcid);

	if (nob) {
		nob->aoi_area_r = r;
	}
}

void f_get_npc_circle_field(void)
{
	SET_ALL_ARGS
	fs_npc_object_t *nob;
	int npcid = ARGS(0)->u.number;

	POP_ALL_ARGS

	nob = fs_npc_object(npcid);

	if (nob) {
		push_number(nob->aoi_area_r);
		return;
	}
	push_number(0);
}

void f_in_npc_field(void)
{
	fs_npc_object_t *nob;
	fs_scene_entry_t *entry;
	SET_ALL_ARGS
	int z = ARGS(0)->u.number;
	int x = ARGS(1)->u.number;
	int y = ARGS(2)->u.number;
	nob = fs_npc_object(ARGS(3)->u.number);

	POP_ALL_ARGS

	if (nob && nob->aoi_area_r) {
		entry = &(nob->entry);
		if (z == entry->z) {
			int r = (x - entry->x) * (x - entry->x) + (y - entry->y) * (y - entry->y);
			if (r <= nob->aoi_area_r * nob->aoi_area_r) {
				push_number(1);
				return;
			}
		}
	}
	push_number(0);
	return;
}

void f_is_npc_online(void)
{
	SET_ALL_ARGS
	int ret = is_npc_online(ARGS(0)->u.number);
	POP_ALL_ARGS
	push_number(ret);
}

// test
void f_get_npc_map(void)
{
	SET_ALL_ARGS
	mapping_t *m = fs_get_npc_map(ARGS(0)->u.number, ARGS(1)->u.number);
	POP_ALL_ARGS

	if (!m) {
		push_svalue(&const0u);
		return;
	}
	push_mapping(m);
}


void f_set_npc_map(void)
{
	SET_ALL_ARGS
	fs_set_npc_map(ARGS(0)->u.number, ARGS(1)->u.map, ARGS(2)->u.number);
	POP_ALL_ARGS
}

void f_set_npc_fightid(void)
{
	SET_ALL_ARGS
	int npcid = ARGS(0)->u.number;
	int fightid = ARGS(1)->u.number;
	fs_npc_object_t *nob;
	nob = fs_npc_object(npcid);
	if (nob) {
		nob->iFighting = fightid;
	}
	POP_ALL_ARGS
}

void f_get_npc_fightid(void)
{
	SET_ALL_ARGS
	int npcid = ARGS(0)->u.number;
	fs_npc_object_t *nob;
	nob = fs_npc_object(npcid);
	POP_ALL_ARGS
	if (nob) {
		push_number(nob->iFighting);
	} else {
		push_number(0);
	}
}

void f_set_npc_status(void)
{
	SET_ALL_ARGS
	fs_npc_object_t *nob;
	int npcid = ARGS(0)->u.number;
	int status = ARGS(1)->u.number;
	int sec = ARGS(2)->u.number;
	int target = ARGS(3)->u.number;
	POP_ALL_ARGS

	nob = fs_npc_object(npcid);

	if (nob) {
		nob->status = status;
		nob->status_sec = sec;
		nob->status_tar = target;
	}
}

void f_get_npc_status(void)
{
	SET_ALL_ARGS
	array_t * v; 
	fs_npc_object_t *nob;
	int npcid = ARGS(0)->u.number;
	POP_ALL_ARGS

	nob = fs_npc_object(npcid);

	if (nob) {
		v = allocate_empty_array(3); 
		v->item[0].type = T_NUMBER;                                                                                                                                                                      
		v->item[1].type = T_NUMBER;                                                                                                                                                                      
		v->item[2].type = T_NUMBER;                                                                                                                                                                      
		v->item[0].u.number = nob->status;                                                                                                                                                                         
		v->item[1].u.number = nob->status_sec;  
		v->item[2].u.number = nob->status_tar;  
		push_refed_array(v);
	} else {
		push_svalue(&const0);
	}
}


void f_set_effect_npc(void)
{
	SET_ALL_ARGS
	fs_npc_object_t *nob;
	int npcid = ARGS(0)->u.number;
	int is_effect = ARGS(1)->u.number;
	POP_ALL_ARGS

	nob = fs_npc_object(npcid);

	if (nob) {
		nob->is_effect_npc = is_effect;
	}
}

void f_is_effect_npc(void)
{
	SET_ALL_ARGS
	fs_npc_object_t *nob;
	int npcid = ARGS(0)->u.number;
	POP_ALL_ARGS

	nob = fs_npc_object(npcid);

	if (nob) {
		push_number(nob->is_effect_npc);
	} else {
		push_svalue(0);
	}
}
