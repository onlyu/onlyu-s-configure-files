// ==========================================
// Purpose  : 场景地图管理
// Created  : 2010-04-30
// By       : Mouse
// History  : 2010-04-30  Mouse create
//
// 说明:     1. 虚拟ID不做回收, 从10000开始. 重启之后虚拟ID回到起点,不会有问题.
// ==========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "config.h"
#include "fs_mem_pool.h"
#include "fs_aoi.h"
#include "fs_scene.h"
#include "fs_hlist.h"
#include "fs_common.h"
#include "fs_log.h"
#include "fs_user.h"
#include "fs_npc.h"


static int bInit = 0;
static int iSceneVID = VIRTUAL_SCENE_LEVEL;                /*虚拟场景开始编号*/

fs_memory_pool_t *gpScenePool;					/*场景内存池*/
fs_memory_pool_t *gpCellPool;					/*格子内存池*/
fs_memory_pool_t *gpJmpPool;                    /*跳转内存池*/
fs_obj_hash_t *gpMapDescTbl;					/*地图描述表*/
fs_obj_hash_t *gpSceneTable;					/*场景描述表*/

struct scene_vid_s{
	TAILQ_ENTRY(scene_vid_s) list;
	int num;
};

// 初始话表
void fs_init_sys_scene_module(int max_num)
{
	if (!bInit) {
		// TODO: 可以考虑预申请vid丢队列里面去
		gpScenePool = fs_create_memory_pool(sizeof(fs_scene_t), max_num);
		// 预分配cell
		gpCellPool = fs_create_memory_pool(sizeof(fs_cell_t), max_num * 500);
		gpJmpPool = fs_create_memory_pool(sizeof(fs_jmp_t), max_num * 10);
		gpMapDescTbl = fs_ht_create_hash_table(MAP_HSIZE);
		gpSceneTable = fs_ht_create_hash_table(max_num);
		bInit = 1;
	}
}

void fs_dump_scene_ob()
{
	fs_dump_mem_pool_desc(gpScenePool, "scene");
	fs_dump_mem_pool_desc(gpCellPool, "scene gride");
	fs_dump_mem_pool_desc(gpJmpPool, "scene jump");
}


// ===========================================================
// 地图模块加载 

static fs_map_t *NewMap()
{
	return (fs_map_t *) malloc(sizeof(fs_map_t));
}

// 设置地图blk,jmp
fs_map_t *fs_load_map(int mapid)
{
	fs_fss_cell_t *cells;
	fs_fss_cell_t *tmpcell;
	fs_cell_t *mapcell;
	int w, h, wxh, i;
	fs_map_t *map;

	map = FS_HT_FIND_INT(gpMapDescTbl, mapid);
	if (map) {
		return map;
	}

	w = 2560;
	h = 660;
	wxh = w * h;

	log_debug(MOD_SCENE, "start load map[%d]...", mapid);
		log_debug(MOD_SCENE, "open[%d] success", mapid);

		map = NewMap();
		memset(map, 0x00, sizeof(fs_map_t));
		map->id = mapid;

		map->w = w;
		map->h = h;

		// 这个不做回收
		map->pcells = (fs_cell_t *) malloc(sizeof(fs_map_t) * wxh);
		cells = malloc(sizeof(fs_fss_cell_t) * wxh);

		memset(map->pcells, 0x00, sizeof(fs_map_t) * wxh);
		memset(cells, 0x00, sizeof(fs_fss_cell_t) * wxh);


		log_debug(MOD_SCENE, "start load cell[%d], w:%d, h:%d", map->id, map->w, map->h );
		for (i=0; i<wxh; ++i)
		{
			tmpcell = &cells[i];
			if (POS_NOT_VALID(map, tmpcell->x, tmpcell->y)) {
				log_error(MOD_SCENE, "map[%d] jmp_id[%d] [%d, %d]", mapid, tmpcell->jump_id, tmpcell->x, tmpcell->y);
				continue;
			}
			mapcell = MAP_CELL(map, tmpcell->x, (map->h - 1 - tmpcell->y));
			if (tmpcell->terrain_block) {
				// log_error(MOD_SCENE, "cell[%d,%d] terrain[%d,%d]", tmpcell->x, tmpcell->y, tmpcell->terrain_block & TERRAIN_BIT, tmpcell->terrain_block & BLOCK_BIT);
				mapcell->terrain_blk = tmpcell->terrain_block;
			}
			mapcell->acc_ref = 0;
			/*
			if (tmpcell->jump_id != 255) {
				log_error(MOD_SCENE, "map[%d] jmp_id[%d] [%d, %d]", mapid, tmpcell->jump_id, tmpcell->x, map->h - 1 - tmpcell->y);
			}
			*/
			mapcell->jmp_id = tmpcell->jump_id;
			mapcell->acc_index = 0;
			mapcell->writed = 0;
			//printf("%d,%d\n", tmpcell->x, tmpcell->y);
		}


		free(cells);

		FS_HT_INSERT_INT(gpMapDescTbl, map->id, map);
		log_debug(MOD_SCENE, "load map[%d], w:%d, h:%d", map->id, map->w, map->h );

		return map;
	log_debug(MOD_SCENE, "load map[%d] error!", mapid);
}

int fs_foreach_all_maps(int (*fp)(fs_map_t*))
{
	fs_map_t *oMap;
	fs_ht_node_t *hnode;
	int ret;

	FOR_EACH_HTABLE_OB(gpMapDescTbl, hnode)
	{
		oMap = (fs_map_t *) hnode->ob;

		ret = (*fp) (oMap);

		if (!ret) return 0;
	}
	return 1;
}

// ===========================================================
// 场景管理:
// 包括: 虚场景和实场景
// 说明: 实场景即为与地图编号一样的场景;虚场景即为副本场景.
//       场景AOI机制采用九宫格管理, AOI响应参考fs_aoi.c, 这里只做简单的场景副本管理
// 图解:
//   fs_scene_t
//    |
//    |
//    V
// ---------------------
// |      |      |      | 
// | grid |      |   ---|-----> list: NPC    -->[entry]-->[entry]-->...
// |      |      |      |             Player -->[entry]-->[entry]-->...
// ---------------------|            
// |      |      |      |
// |      |      |      |
// |      |      |      |
// ---------------------|
// |      |      |      |
// |      |      |      |
// |      |      |      |
// ---------------------
//

// 新建场景节点,从内存池获取
static fs_scene_t *fs_new_scene_node()
{
	return fs_malloc_node(gpScenePool);
}

fs_scene_t *fs_find_scene_node(int sceneid)
{
	return FS_HT_FIND_INT(gpSceneTable, sceneid);
}

static inline fs_jmp_t *fs_new_jmp_node()
{
	return fs_malloc_node(gpJmpPool);
}

static inline void fs_remove_jmp_node(fs_jmp_t *pnode)
{
	fs_free_node(gpJmpPool, pnode);
}

static inline fs_cell_t *fs_new_cell_node()
{
	return fs_malloc_node(gpCellPool);
}

static inline void fs_remove_cell_node(fs_cell_t *pcell)
{
	fs_free_node(gpCellPool, pcell);
}

inline fs_cell_t *fs_get_cell(fs_scene_t *scene, int x, int y)
{
	if (scene->ppcells) {
		return SCENE_CELL(scene, x, y);
	}
	return MAP_CELL(scene->map, x, y);
}


// 删除场景
int fs_remove_scene(int sceneid)
{
	// 实场景不能删
	// 虚拟场景则回收ID
	fs_scene_t *scene = FS_HT_FIND_INT(gpSceneTable, sceneid);
	int i, x, y, cellmax;
	fs_ht_node_t *hnode;
	fs_jmp_t *jmp;

	// 实场景不做回收
	if (sceneid <= VIRTUAL_SCENE_LEVEL) return 0;

	if (!scene) return 0;

	// jmp_table
	// ppcells
	// grids

	// 如果还有人物在格子里面，不删除
	for ( y = 0; y < scene->grid_h; y++ ) {
		for ( x = 0; x < scene->grid_w; x++ ) {     
			if (fs_char_in_grid(&(scene->grids[scene->grid_w*y + x]))) {
				log_error(MOD_SCENE, "user or npc in scene, when remove scene[%d]!", sceneid);
				return 0;
			}
		} 
	}  

	// 删除grid
	for ( y = 0; y < scene->grid_h; y++ ) {
		for ( x = 0; x < scene->grid_w; x++ ) {     
			fs_remove_grid(&(scene->grids[scene->grid_w*y + x]));
		} 
	}  

	// 删除cell
	if (scene->ppcells) {
		cellmax = scene->w * scene->h;
		for (i=0; i<cellmax; i++) {
			if (scene->ppcells[i]->writed) {
				fs_remove_cell_node(scene->ppcells[i]);
			}
		}
		free(scene->ppcells);
	}

	// 删除跳转
	FOR_EACH_HTABLE_OB(scene->jmp_table, hnode) {
		jmp = (fs_jmp_t *) hnode->ob;
		fs_remove_jmp_node(jmp);
	}

	fs_ht_free_hash_table(scene->jmp_table);
	free(scene->grids);
	fs_free_node(gpScenePool, scene);

	FS_HT_REMOVE_INT(gpSceneTable, sceneid);
	return 1;
}

static inline fs_cell_t *fs_copy_cell(fs_cell_t *cell)
{
	fs_cell_t *newcell;

	// newcell = (fs_cell_t *) malloc(sizeof(fs_cell_t));

	newcell = fs_new_cell_node();

	// 不复制动态阻挡
	newcell->terrain_blk = cell->terrain_blk & (TERRAIN_BIT | NORMAL_BLOCK_BIT);
	newcell->acc_ref = cell->acc_ref;
	newcell->jmp_id = cell->jmp_id;
	newcell->acc_index = cell->acc_index;
	newcell->writed = 1;
	return newcell;
}

static inline int remove_jump_point(int sceneid, int jmp_id)
{
	fs_scene_t *scene = FS_HT_FIND_INT(gpSceneTable, sceneid);

	if (!scene) {
		log_error(MOD_SCENE, "can't find scene[%d]", sceneid);
		return 0;
	}

	if (scene->jmp_table) {
		fs_jmp_t *jmp = FS_HT_FIND_INT(scene->jmp_table, jmp_id);
		if (jmp) {
			fs_remove_jmp_node(jmp);
			FS_HT_REMOVE_INT(scene->jmp_table, jmp_id);
			return 1;
		}
	}
	return 0;
}

static inline int set_jump_point(int fscene, int jmp_id, svalue_t *pos, int fly_limit)
{
	fs_scene_t *scene;
	fs_jmp_t *jmp;
	int tx, ty, tscene;


	if (!IS_LPC_ARR(pos) || LPC_ARR_SIZE(pos) < 3) {
		return 0;
	}



	scene = FS_HT_FIND_INT(gpSceneTable, fscene);

	if (!scene) {
		log_error(MOD_SCENE, "can't find scene[%d]", fscene);
		return 0;
	}

	tscene = LPC_ARR_ITEM(pos, 0)->u.number;
	tx = LPC_ARR_ITEM(pos, 1)->u.number;
	ty = LPC_ARR_ITEM(pos, 2)->u.number;

	jmp = FS_HT_FIND_INT(scene->jmp_table, jmp_id);

	if (!jmp) {
		jmp = fs_new_jmp_node();
	}
	jmp->scene = tscene;
	jmp->x = tx;
	jmp->y = ty;
	jmp->fly_limit = fly_limit;
	FS_HT_INSERT_INT(scene->jmp_table, jmp_id, jmp);
	return 1;
}

static void assert_check_scene_cell_init(fs_scene_t *scene)
{
	if (scene->ppcells) return;

	fs_map_t *map = scene->map;
	int cellmax, i;
	cellmax = map->w * map->h;

	scene->ppcells = (fs_cell_t **) malloc(sizeof(fs_cell_t *) * cellmax);
	for (i = 0; i < cellmax; i++ ) {
		scene->ppcells[i] = &map->pcells[i];
	}
}

// 新建场景
static fs_scene_t *fs_new_scene(fs_map_t *map, int grid_size)
{
	int x, y;
	fs_scene_t *new_scene;
	struct fs_grid_s *lsGrid;

	new_scene = fs_new_scene_node();
	if (!new_scene) return NULL;

	if (grid_size) {
		new_scene->grid_size = grid_size;
	} else {
		new_scene->grid_size = GRID_SIZE;
	}

	new_scene->w = map->w;
	new_scene->h = map->h;
	new_scene->map = map;
	new_scene->id = map->id;          //实场景的id,与地图id一样
	new_scene->grid_w = (map->w + new_scene->grid_size - 1)/new_scene->grid_size;
	new_scene->grid_h = (map->h + new_scene->grid_size - 1)/new_scene->grid_size;
	new_scene->ppcells = NULL;

	lsGrid = (struct fs_grid_s * ) malloc(sizeof(struct fs_grid_s) * new_scene->grid_w * new_scene->grid_h);
	for ( y = 0; y < new_scene->grid_h; y++ ) {
		for ( x = 0; x < new_scene->grid_w; x++ ) {     
			fs_init_grid(&(lsGrid[new_scene->grid_w*y + x]), new_scene, x, y);
		} 
	}  
	new_scene->grids = lsGrid;
	new_scene->weather = 0;
	new_scene->isnight = 0;
	new_scene->synctime = 5;
	new_scene->anlei = 1;
	new_scene->warfog = 0;
	// 默认为3*3的区域
	new_scene->aoi_scope = 1;
	new_scene->jmp_table = fs_ht_create_hash_table(32);

	return new_scene;
}

// 创建一个与地图id一样的场景
static int fs_create_scene(int mapid)
{
	fs_map_t *map;
	fs_scene_t *scene, *new_scene;

	map = fs_load_map(mapid);

	if (!map) {
		log_error(MOD_SCENE, "can't load map[%d]", mapid);
		return 0;
	}

	scene = FS_HT_FIND_INT(gpSceneTable, mapid);
	if (scene) {
		return mapid;
	}

	new_scene = fs_new_scene(map, 0);
	if (!new_scene) {
		return 0;
	}

	new_scene->id = mapid;
	// TODO:载入NPC,以及恢复心跳

	FS_HT_INSERT_INT(gpSceneTable, mapid, new_scene);
	return new_scene->id;
}

// 返回虚拟场景号
int fs_clone_scene(int mapid, int grid_size)
{
	int sceneid;
	fs_map_t *map;
	fs_scene_t *scene, *new_scene;

	map = fs_load_map(mapid);

	if (!map) {
		log_error(MOD_SCENE, "can't get map[%d]", mapid);
		return 0;
	}
	sceneid = ++iSceneVID;

	scene = FS_HT_FIND_INT(gpSceneTable, sceneid);
	if (scene) {
		log_debug(MOD_SCENE, "vid[%d] reclone, error!!", sceneid);
		return 0;
	}

	new_scene = fs_new_scene(map, grid_size);
	if (!new_scene) {
		log_debug(MOD_SCENE, "new_scene when clone scene, error!!");
		return 0;
	}
	new_scene->id = sceneid;

	FS_HT_INSERT_INT(gpSceneTable, sceneid, new_scene);

	log_debug(MOD_SCENE, "clone scene[%d]: map[%d] ok!", sceneid, mapid );
	return sceneid;
}


// ===========================================================
// 奇遇事件

int set_scene_accident(int sceneid, svalue_t *arrpos, int acc_index)
{
	fs_scene_t *scene;
	fs_cell_t *pcell;
	svalue_t *pos;
	int i, x, y;

	if (!IS_LPC_ARR(arrpos)) {
		return 0;
	}
	scene = FS_HT_FIND_INT(gpSceneTable, sceneid);
	if (!scene) {
		return 0;
	}

	assert_check_scene_cell_init(scene);

	for (i = 0; i < LPC_ARR_SIZE(arrpos); i++) {
		pos = LPC_ARR_ITEM(arrpos, i);

		if (!IS_LPC_ARR(pos) || LPC_ARR_SIZE(pos) != 2) continue;
		x = LPC_ARR_ITEM(pos, 0)->u.number;
		y = LPC_ARR_ITEM(pos, 1)->u.number;

		if (POS_NOT_VALID(scene, x, y)) {
			log_error(MOD_SCENE, "error, scene[%d] pos(%d,%d) not valid", sceneid, x, y);
		}

		pcell = fs_get_cell(scene, x, y);
		if (!pcell->writed) {
			pcell = fs_copy_cell(pcell);
			SCENE_CELL(scene, x, y) = pcell;
		}
		if (pcell->acc_index) {
			if (pcell->acc_index != acc_index) {
				log_error(MOD_SCENE, "error, scene[%d] pos(%d,%d) has been set acc point!", sceneid, x, y);
			}
		} else {
			pcell->acc_index = acc_index;
		}
	}
	return 1;
}

int get_cell_acc_index(int sceneid, int x, int y)
{
	fs_scene_t *scene;
	fs_cell_t *pcell;
	scene = FS_HT_FIND_INT(gpSceneTable, sceneid);
	if (!scene) {
		return 0;
	}
	if (POS_NOT_VALID(scene, x, y)) {
		return 0;
	}
	pcell = fs_get_cell(scene, x, y);
	return pcell->acc_index;
}

int set_dynamic_block(int sceneid, svalue_t *arrpos, int isblock)
{
	fs_scene_t *scene;
	fs_cell_t *pcell;
	svalue_t *pos;
	int i, x, y;

	if (!IS_LPC_ARR(arrpos)) {
		return 0;
	}
	scene = FS_HT_FIND_INT(gpSceneTable, sceneid);
	if (!scene) {
		return 0;
	}

	assert_check_scene_cell_init(scene);

	for (i = 0; i < LPC_ARR_SIZE(arrpos); i++) {
		pos = LPC_ARR_ITEM(arrpos, i);

		if (!IS_LPC_ARR(pos) || LPC_ARR_SIZE(pos) != 2) continue;
		x = LPC_ARR_ITEM(pos, 0)->u.number;
		y = LPC_ARR_ITEM(pos, 1)->u.number;

		if (POS_NOT_VALID(scene, x, y)) {
			log_error(MOD_SCENE, "scene[%d] pos(%d,%d) not valid", sceneid, x, y);
		}

		pcell = fs_get_cell(scene, x, y);
		if (!pcell->writed) {
			pcell = fs_copy_cell(pcell);
			SCENE_CELL(scene, x, y) = pcell;
		}
		if (isblock) {
			pcell->terrain_blk |= DYNAMIC_BLOCK_BIT;
		} else {
			pcell->terrain_blk &= ~DYNAMIC_BLOCK_BIT;
		}
	}
	return 1;
}

int set_scene_terrain(int sceneid, svalue_t *arrpos, int terrain)
{
	fs_scene_t *scene;
	fs_cell_t *pcell;
	svalue_t *pos;
	int i, x, y;

	if (!IS_LPC_ARR(arrpos)) {
		return 0;
	}
	scene = FS_HT_FIND_INT(gpSceneTable, sceneid);
	if (!scene) {
		return 0;
	}

	assert_check_scene_cell_init(scene);

	for (i = 0; i < LPC_ARR_SIZE(arrpos); i++) {
		pos = LPC_ARR_ITEM(arrpos, i);

		if (!IS_LPC_ARR(pos) || LPC_ARR_SIZE(pos) != 2) continue;
		x = LPC_ARR_ITEM(pos, 0)->u.number;
		y = LPC_ARR_ITEM(pos, 1)->u.number;

		if (POS_NOT_VALID(scene, x, y)) {
			log_error(MOD_SCENE, "scene[%d] pos(%d,%d) not valid", sceneid, x, y);
		}

		pcell = fs_get_cell(scene, x, y);
		if (!pcell->writed) {
			pcell = fs_copy_cell(pcell);
			SCENE_CELL(scene, x, y) = pcell;
		}
		pcell->terrain_blk |= TERRAIN_2_BIT(terrain);
	}
	return 1;
}

int get_scene_terrain(int sceneid, int x, int y)
{
	fs_scene_t *scene;
	fs_cell_t *pcell;
	
	scene = FS_HT_FIND_INT(gpSceneTable, sceneid);
	if (!scene) {
		return 0;
	}

	pcell = fs_get_cell(scene, x, y);

	return CELL_TERRAIN(pcell);
}


// ===========================================
// efun

// 创建虚场景
void f_clone_scene(void)
{
	SET_ALL_ARGS
	int ret = fs_clone_scene(ARGS(0)->u.number, ARGS(1)->u.number);
	POP_ALL_ARGS
	push_number(ret);
}

// 创建实场景
void f_create_scene(void)
{
	SET_ALL_ARGS
	int ret = fs_create_scene(ARGS(0)->u.number);
	POP_ALL_ARGS
	push_number(ret);
}

void f_remove_scene(void)
{
	SET_ALL_ARGS
	int ret = fs_remove_scene(ARGS(0)->u.number);
	POP_ALL_ARGS
	push_number(ret);
}


void f_get_real_scene(void)
{
	SET_ALL_ARGS
	int z = ARGS(0)->u.number;
	int mapid = 0;
	fs_scene_t *scene;
	scene = FS_HT_FIND_INT(gpSceneTable, z);
	if (scene) {
		mapid = scene->map->id;
	}
	POP_ALL_ARGS
	push_number(mapid);
}

void f_set_scene_weather(void)
{
	SET_ALL_ARGS
	int z = ARGS(0)->u.number;
	int weather = ARGS(1)->u.number;
	fs_scene_t *scene;

	scene = FS_HT_FIND_INT(gpSceneTable, z);

	if (scene) {
		scene->weather = weather;
	}
	POP_ALL_ARGS
}

void f_set_scene_night(void)
{
	SET_ALL_ARGS
	int z = ARGS(0)->u.number;
	int isnight = ARGS(1)->u.number;
	fs_scene_t *scene;

	scene = FS_HT_FIND_INT(gpSceneTable, z);

	if (scene) {
		scene->isnight = isnight;
	}
	POP_ALL_ARGS
}

void f_set_walk_synctime(void)
{
	SET_ALL_ARGS
	int z = ARGS(0)->u.number;
	int time = ARGS(1)->u.number;
	fs_scene_t *scene;

	scene = FS_HT_FIND_INT(gpSceneTable, z);

	if (scene) {
		scene->synctime = time;
	}
	POP_ALL_ARGS
}

void f_set_scene_anlei(void)
{
	SET_ALL_ARGS
	int z = ARGS(0)->u.number;
	int isanlei = ARGS(1)->u.number;
	fs_scene_t *scene;

	scene = FS_HT_FIND_INT(gpSceneTable, z);

	if (scene) {
		scene->anlei = isanlei;
	}
	POP_ALL_ARGS
}

// 设置战斗迷雾
void f_set_scene_warfog(void)
{
	SET_ALL_ARGS
	int z = ARGS(0)->u.number;
	int isfog = ARGS(1)->u.number;
	fs_scene_t *scene;

	scene = FS_HT_FIND_INT(gpSceneTable, z);

	if (scene) {
		scene->warfog = isfog;
	}
	POP_ALL_ARGS
	
}

void f_set_jump_point(void)
{
	SET_ALL_ARGS
	int fz, jmp_id, fly_limit, ret;
	svalue_t *pos;

	fz = ARGS(0)->u.number;
	jmp_id = ARGS(1)->u.number;
	pos = ARGS(2);
	fly_limit = ARGS(3)->u.number;
	// fly_limit = ARGS(5)->u.number;
	POP_ALL_ARGS
	ret = set_jump_point(fz, jmp_id, pos, fly_limit);
	push_number(ret);
}

void f_remove_jump_point(void)
{
	SET_ALL_ARGS
	int scene = ARGS(0)->u.number;
	int jmp_id = ARGS(1)->u.number;
	int ret = remove_jump_point(scene, jmp_id);
	POP_ALL_ARGS
	push_number(ret);
}

void f_set_aoi_scope(void)
{
	SET_ALL_ARGS
	int z = ARGS(0)->u.number;
	int scope = ARGS(1)->u.number;
	fs_scene_t *scene;

	scene = FS_HT_FIND_INT(gpSceneTable, z);

	if (scene) {
		scene->aoi_scope = scope;
	}
	POP_ALL_ARGS
}

void f_get_scene_wh(void)
{
	SET_ALL_ARGS
	int z = ARGS(0)->u.number;
	fs_scene_t *scene;
	POP_ALL_ARGS

	scene = FS_HT_FIND_INT(gpSceneTable, z);

	if (scene) {
		array_t *vec;
		vec = allocate_array(2);
		vec->item[0].type = T_NUMBER;
		vec->item[0].u.number = scene->w;
		vec->item[1].type = T_NUMBER;
		vec->item[1].u.number = scene->h;
		push_refed_array(vec);
		return;
	}
	push_svalue(&const0u);
}

// ========================================================
// aoi事件

// 设置动态阻挡
void f_set_dynamic_block(void)
{
	SET_ALL_ARGS
	set_dynamic_block(ARGS(0)->u.number, ARGS(1), ARGS(2)->u.number);
	POP_ALL_ARGS
}


// 设置地形，临时用
void f_set_scene_terrain(void)
{
	SET_ALL_ARGS
	set_scene_terrain(ARGS(0)->u.number, ARGS(1), ARGS(2)->u.number);
	POP_ALL_ARGS
}

void f_get_scene_terrain(void)
{
	SET_ALL_ARGS
	int ret = get_scene_terrain(ARGS(0)->u.number, ARGS(1)->u.number, ARGS(2)->u.number);
	POP_ALL_ARGS
	push_number(ret);
}


void f_set_scene_accident(void)
{
	SET_ALL_ARGS
	int ret = set_scene_accident(ARGS(0)->u.number, ARGS(1), ARGS(2)->u.number);
	POP_ALL_ARGS
	push_number(ret);
}

void f_get_cell_acc_index(void)
{
	SET_ALL_ARGS
	int ret = get_cell_acc_index(ARGS(0)->u.number, ARGS(1)->u.number, ARGS(2)->u.number);
	POP_ALL_ARGS
	push_number(ret);
}
