//为了编译通过这两个函数临时放在这里
#include <macros.h>
#include <item_key.h>
#include <frames.h>
#include "/rc/rpc/item.h"
#include <debug.h>
#include "name.c"
//#include "equal.h"
//#include <save.h>
//#include <mail.h>

static object logger;

varargs int CreateItem(string cType, int iAmount);
int addItem(object user, string ctype, int count, int bagId)
{
	int res;
	int itemId = CreateItem(ctype, count);
	if ( itemId < 1 )
		return itemId;

	res = user->XAddItem(itemId, bagId);
	if ( res < 1)
	{
		destroy_item(itemId);
		return 0;
	}
	return itemId;
}


////////////////


void SetAmount(int iItem, int iAmount)
{
	logger->Log("setamount iItem=%d iAmount=%d", iItem, iAmount);
	int iOwner;

	SetItemSave( iItem, K_ITEM_AMOUNT, iAmount );
	iOwner = GetItemTemp(iItem, KT_ITEM_OWNER);

	//debug_message( sprintf("SetItemAmount: iOwner %d, 0x%x, iAmount %d.", iOwner, iItem, iAmount) );

	if (iAmount == 0)
	{
		DestroyItem(iItem);
		rpc_client_item_del(iOwner, iItem);
		logger->Log("Delete iOwner:%d iItem=%d", iOwner, iItem);
		return;
	}	

	if (iOwner) {
		// 协议通知client
		rpc_client_item_amount( iOwner, iItem, iAmount );
	}
}

private int _ModiAmount(int iItem, int iDelta)
{
	int iAmount, iMaxAmount;

	iMaxAmount = GetItemTemp(iItem, KT_ITEM_MAXAMOUNT);
	assert( iMaxAmount > 0 );

	iAmount = GetItemSave(iItem, K_ITEM_AMOUNT) + iDelta;

	if ( iAmount > iMaxAmount )
	{	
		debug_message(sprintf("ERROR: 0x%x modiamount +%d greater than iMaxAmount %d, reset to maxamount. owner is %d.", iItem, iDelta, iMaxAmount, GetItemSave( iItem, KT_ITEM_OWNER)) );
		iAmount = iMaxAmount;
	}	

	SetAmount( iItem, iAmount );
	return iAmount ;
}

// 返回 iItem 的剩余个数
int IncAmount(int iItem, int iDelta)
{
	return _ModiAmount( iItem, iDelta);
} 

// 返回 iItem 的剩余个数
int DecAmount(int iItem, int iDelta)
{
	int iAmount = _ModiAmount( iItem, -iDelta);

	if ( iAmount <= 0)
	{
		DestroyItem(iItem);	
	}
	return iAmount;
} 


// TODO
int CloneItem( int iItem, int iAmount)
{
	string cType;
	int iClone;

	cType = GetItemSave(iItem, K_ITEM_TYPE);
	iClone = CreateItem(cType);

	if ( iClone > 0 )
	{
		foreach( mixed key, mixed value in get_item_map(iItem, PERM_VAR) )
		{
			SetItemSave(iClone, key, value);	
		}
		foreach( mixed key, mixed value in get_item_map(iItem, TEMP_VAR) )
		{
			SetItemTemp(iClone, key, value);	
		}
	}

	SetItemSave(iClone, K_ITEM_AMOUNT, iAmount);
	SetItemTemp(iClone, KT_ITEM_OWNER, 0);
	SetItemTemp(iClone, KT_ITEM_BAG, 0);
	SetItemTemp(iClone, KT_ITEM_POS, 0);

	return iClone;
}

// TODO 是否被锁定不可以交易
int IsLocked(int iItem)
{
	if (GetItemSave(iItem, K_ITEM_LOCK) ) return 1;
	if (GetItemTemp(iItem, KT_ITEM_NOMERGE) ) return 1;

	return 0 ;
}

int IsLockedByData(mapping save_data)
{
	if (save_data[K_ITEM_LOCK]) return 1;
	if (save_data[KT_ITEM_NOMERGE]) return 1;
	return 0;
}

int CanDrop(int iItem)
{
	// 任务物品, 不允许丢弃
	if (sizeof(GetItemSave(iItem, K_ITEM_TASK_OWNER))) {
		return 0;
	}

	if (GetItemTemp(iItem, KT_ITEM_BAG) == ITEM_BAG_TASK) {
		return 0;
	}
	return 1;
}

int CanMoveTo(int iItemId, int iBagTo, int iPosTo)
{
	int iBagFrom, iPosFrom ;

	if (IsLocked(iItemId))
		return 0;

	iBagFrom = GetItemTemp(iItemId, KT_ITEM_BAG);
	iPosFrom = GetItemTemp(iItemId, KT_ITEM_POS);

	// check iBagFrom && iBagTo
	if (iBagFrom != iBagTo) {
		return 0;
	}

	if (!IsNormalItemBag(iBagTo))
		return 0;


	return 1;
}

int CanMerge(int iSrc, int iTarget)
{
	return 0;
	int iMaxAmount ;
	string cSrcMissID, cTarMissID;

	if ( iSrc == iTarget ) 
		return 0;

	if ( GetItemSave(iSrc, K_ITEM_TYPE) != GetItemSave(iTarget, K_ITEM_TYPE) )
		return 0;

	if ( IsLocked(iSrc) || IsLocked(iTarget) ) 
		return 0;

	iMaxAmount = GetItemTemp(iTarget, KT_ITEM_MAXAMOUNT);
	if ( iMaxAmount < 2 )
		return 0;

	/*
	if ( GetItemSave(iTarget, K_ITEM_AMOUNT) + GetItemSave(iSrc, K_ITEM_AMOUNT) > iMaxAmount ) 
		return 0;
	*/	

	// 如果是任务物品, 那么必须是同一个任务的任务物品才能合并
	cSrcMissID = GetItemSave(iSrc, K_ITEM_TASK_OWNER);
	cTarMissID = GetItemSave(iTarget, K_ITEM_TASK_OWNER);
	if ((sizeof(cSrcMissID) != sizeof(cTarMissID)) || (cSrcMissID != cTarMissID))
		return 0;

	return 1;
}

int CanMergeByData(mapping save_data1, mapping save_data2)
{
	if (save_data1[K_ITEM_TYPE] != save_data2[K_ITEM_TYPE]) {
		return 0;
	}
	int max_amount = GetMaxAmountByType(save_data1[K_ITEM_TYPE]);

	if (max_amount < 2) {
		return 0;
	}
	if ( IsLockedByData(save_data1) || IsLockedByData(save_data2) ) 
		return 0;

	string cSrcMissID = save_data1[K_ITEM_TASK_OWNER];
	string cTarMissID = save_data2[K_ITEM_TASK_OWNER];
	if ((sizeof(cSrcMissID) != sizeof(cTarMissID)) || (cSrcMissID != cTarMissID))
		return 0;

	return 1;
}

int CanUse(object oUser, int iItemId)
{
	if (IsLocked(iItemId))
		return 0;

	if (!IsNormalItemBag(GetItemTemp(iItemId, KT_ITEM_BAG)) )
		return 0;

	return 1;
}

int CanUseInFight(object oUser, int iItemId)
{
	if (IsLocked(iItemId))
		return 0;

	if (!IsFightBag(GetItemTemp(iItemId, KT_ITEM_BAG)))
		return 0;

	return 1;
}

int CanTrade(object oUser, int iItemId)
{
	if (IsLocked(iItemId))
		return 0;

	if (!IsNormalItemBag(GetItemTemp(iItemId, KT_ITEM_BAG)) )
		return 0;

	return CanItemTrade(iItemId);
}

void rpc_AddItemToUser(int usernum, int iItemId)
{
	int iAmount;
	int iLockType;
	int * POS;

	class item_add_t _add_t = new( class item_add_t );
	class item_pos_t _pos = new( class item_pos_t ); 
	class item_info_t _info = new( class item_info_t );

	POS = ToClientPos( GetItemTemp(iItemId, KT_ITEM_BAG), GetItemTemp(iItemId, KT_ITEM_POS) );
	_pos->iBag = POS[0];
	_pos->iPos = POS[1];

	_info->iItemId = iItemId;
	_info->iOwner = usernum;
	_info->cType = GetItemSave(iItemId, K_ITEM_TYPE);

	// debug_message(sprintf("xxx dump item save:%O", get_item_map(iItemId, 1)));

	/*
	// 容错代码，每个物品默认iAmount=1 // TODO 删掉
	if ( GetItemSave(iItemId, K_ITEM_AMOUNT) < 1
		&& GetItemTemp( iItemId, KT_ITEM_MAXAMOUNT) )
	{
		SetItemSave( iItemId, K_ITEM_AMOUNT, 1);
	}
	*/

	iAmount = GetItemSave(iItemId, K_ITEM_AMOUNT);
	_info->iAmount = iAmount;

	iLockType = GetItemSave(iItemId, K_ITEM_LOCK) ? GetItemSave(iItemId, K_ITEM_LOCK) : 0 ;
	_info->iLockType = iLockType;

	_add_t->posinfo = _pos;
	_add_t->iteminfo = _info;

	// debug_message( sprintf("rpc_AddItemToUser: 0x%x Add to %d.server:(%d,%d), client(%d,%d), iAmount=%d, iMaxAmount=%d, FreePos=%d", iItemId, usernum, GetItemTemp(iItemId, KT_ITEM_BAG), GetItemTemp(iItemId, KT_ITEM_POS), _pos->iBag, _pos->iPos, iAmount, GetItemTemp(iItemId, KT_ITEM_MAXAMOUNT), get_user(usernum)->ItemFreePos(GetItemTemp(iItemId, KT_ITEM_BAG))) );

	rpc_client_item_add(usernum, _add_t);
}

int AddItemById(object oUser, int itemid)
{
	int iRes ;

	iRes = oUser->XAddItem(itemid);
	if ( iRes < 1 )
	{
		//oUser->TellMe(sprintf("你获得了%d个%s", GetItemSave(itemid, K_ITEM_AMOUNT), GetItemTemp(itemid, KT_ITEM_NAME)));
		destroy_item(itemid); 	
		return 0;
	}

	return iRes;
}

mapping mpCountable = ([]);

// 返回值 0 或者 >1 的数字
int IsCountable(string cType)
{
	int itemid;
	int iRes = 0;
	
	if ( mpCountable[cType] ) 
		return mpCountable[cType];

	itemid = CreateItem(cType);
	iRes = GetItemTemp(itemid, KT_ITEM_MAXAMOUNT) ;
	destroy_item(itemid);

	//debug_message( sprintf("IsCountable %d", iRes) );
	if ( iRes <= 1 ) iRes = 0;

	mpCountable[cType] = iRes;
	return iRes;
}


varargs int CanAddItem(object oUser, string cType, int iAmount, int iBagId)
{
	int iCountable = IsCountable(cType);
	int iFreePos;
	
	if ( !iBagId ) iBagId = ITEM_BAG_NORMAL;
	iFreePos = oUser->ItemFreePos(iBagId);

	if ( !iCountable && iAmount > iFreePos)
		return 0;

	if ( iCountable )
	{
		int iFreeAmount = 0;
		foreach( int _id, int _amount in oUser->GetAmountMap(cType, iBagId) )
			iFreeAmount += (iCountable - _amount);

		if (iFreePos*iCountable+iFreeAmount<iAmount)
			return 0;
	}	

	return 1;
}

/*
private int AddUnCountableItem(object user, string cType, int amount, int iBagId, int bMail, mapping mpProp)
{
	int itemid, iPos, iAdd;
	string cItemName = "";
	int *mail_items = ({});

	assert(amount > 0 );
	iAdd = 0;
	for (int i = 0; i < amount; i ++ )
	{	
		itemid = CreateItem(cType, 1); 

		if (sizeof(mpProp)) {
			foreach (mixed _key, mixed _val in mpProp) {
				SetItemSave(itemid, _key, _val);
			}
		}

		iPos = user->XAddItem(itemid, iBagId);
		//debug_message( sprintf("add pos %d", iPos) );
		if (iPos <= 0) 
		{
			if (bMail) {
				mail_items += ({ itemid });
			}
			else {
				destroy_item(itemid);
				break;
			}
		}
		cItemName = GetItemTemp(itemid, KT_ITEM_NAME);
		iAdd += 1;
	}

	if ( iAdd )
		user->TellMe(sprintf("你获得了%d个%s", iAdd, cItemName));

	if (sizeof(mail_items)) {
		mapping mpMail = ([]);
		string content = "你获得了#R$CONTENT#n的奖励";
		init_mail(mpMail, "系统奖励", content);
		reg_mail_items(mpMail, mail_items);
		send_mail(user->GetId(), mpMail);
		user->TellMe(sprintf("你获得的%s已经通过邮件发送!", cItemName));
	}
	return iAdd;
}

private int AddCountableItem(object oUser, string cType, int iAmount, int iBagId, int bMail, mapping mpProp)
{
	int iRes;
	int itemid = CreateItem(cType, iAmount);
	string message = "";

	if ( itemid < 1 )
		return itemid;

	if (sizeof(mpProp)) {
		foreach (mixed _key, mixed _val in mpProp) {
			SetItemSave(itemid, _key, _val);
		}
	}

	message = sprintf("%d个%s", GetItemSave(itemid, K_ITEM_AMOUNT), GetItemTemp(itemid, KT_ITEM_NAME));

	iRes = oUser->XAddItem(itemid, iBagId);

	if ( iRes < 1 ) // 加不成功
	{
		if (bMail) {
			mapping mpMail = ([]);
			string content = "你获得了#R$CONTENT#n的奖励";
			init_mail(mpMail, "系统奖励", content);
			reg_mail_items(mpMail, ({itemid}));
			send_mail(oUser->GetId(), mpMail);
			oUser->TellMe(sprintf("你获得的%s已经通过邮件发送!", message));
			return 1;
		}
		destroy_item(itemid);
	}
	else {
		oUser->TellMe(sprintf("你获得了%s", message));
	}
	return iRes;
}


// 究级的\全局公用的AddItem
varargs int AddItemByType(object oUser, string cType, int iAmount, int iBagId, int bMail, mapping mpProp)
{
	int iCountable = IsCountable(cType);

	if ( !iBagId ) iBagId = ITEM_BAG_NORMAL;

	if ( !bMail && !CanAddItem(oUser, cType, iAmount, iBagId) )
		return 0;

	if ( !iCountable )
	{
		return AddUnCountableItem(oUser, cType, iAmount, iBagId, bMail, mpProp);
	}
	else
	{
		while ( iAmount > iCountable )
		{
			iAmount -= iCountable;
			AddCountableItem(oUser, cType, iCountable, iBagId, bMail, mpProp); 
		}
		return AddCountableItem(oUser, cType, iAmount, iBagId, bMail, mpProp);
	}
}

int HaveMultiAmountItems(object oUser, string * Types, int TotalAmount)
{

}	

int DelMultiAmountItems(object oUser, string * Types, int TotalAmount)
{

}	
*/

void create()
{
	logger = Import("LOG")->New("item_util");
}

varargs int CreateItem(string cType, int iAmount)
{
	string path = ITEM_DIR + cType;
	int item;
	object ob;

	ob = find_object(path, 1);
	if (!objectp(ob)) {
		logger->Log("can't create item[Type:%s]", cType);
		return 0;
	}

	item = new_item(path);

	if ( iAmount > 0 )
	{
		SetAmount(item, iAmount);
	}

	//TODO: cGblKey
	if ( !GetItemSave(item, K_GLOBAL_KEY) )
	{	
		//string cGblKey = Import("GLOBAL_KEY")->new_item_globalkey();
		//暂时用时间 + 随机数
		string cGblKey = sprintf("%d%d", time(), random(1000000));
		SetItemSave(item, K_GLOBAL_KEY, cGblKey); 
	}

	return item;
}

int restoreItem(mapping mpSave)
{
	string cType = mpSave[K_ITEM_TYPE];
	string path;
	int item;

	if (undefinedp(cType) || !sizeof(cType)) {
		return 0;
	}

	path = ITEM_DIR + cType + ".c";

	if (catch(call_other(path, "???" )) != 0) {
		debug_message(sprintf("can't create item[Type:%s]", cType));
		return 0;
	}

	item = restore_item(path, mpSave);

	return item;
}


