#include <equip.h>
#include <item_key.h>
#include <debug.h>
#include <macros.h>
#include <frames.h>
#include <item.h>
#include <debug.h>
#include <baoshi.h>
#include "/rc/rpc/equip.h"

static mapping staticEquipData = ([]);
static mapping staticXilianData = ([]);
static mapping xilianAttrTable = ([]);
static mapping xilianAttrKeys = ([]);

static mapping staticBaoshiData = ([]);
static mapping staticGradeBaoshiData = ([]);

static mapping staticLocateDesc = ([
		EQUIP_LOCATE_WEAPON : "æ­¦å™¨",
		EQUIP_LOCATE_HAT : "å¸½å­",
		EQUIP_LOCATE_CLOTHES : "è¡£æœ",
		EQUIP_LOCATE_BELT : "ç£å¸¦",
		EQUIP_LOCATE_BRACELET : "ç‰ä½©",
		EQUIP_LOCATE_SHOES : "é‹å­",
	]);

static object _log;

void sendXilianInfo(int uid, int item);


#define QIANGHUA_LIMIT_GRADE    40
#define QIANGHUA_MAX_MIN        (20 * 60)


#define  IS_EQUIP_TYPE(t)        (t[0..1] == "EQ")

int getEquipLocate(string type)
{
	return (ITEM_PATH + type)->getLocate();
}

int getEquipQianghuaValue(string type)
{
	return (ITEM_PATH + type)->getQianghuaValue();
}

mapping getEquipAttr(string type)
{
	return (ITEM_PATH + type)->getQianghuaAttr();
}

int getEquipColor(string type)
{
	return (ITEM_PATH + type)->getEquipColor();
}

int getEquipGrade(string type)
{
	return (ITEM_PATH + type)->getEquipGrade();
}

mapping getEquipDesc(string type)
{
	return (ITEM_PATH + type)->getData();
}


void initXilianAttrTable()
{
	xilianAttrTable = ([]);
	xilianAttrKeys = ([]);
	foreach (int _index, mapping _data in staticXilianData) {
		mapping mpAttr = getOrSetMappingDepth(xilianAttrTable, ({ _data[K_EQUIP_GRADE], _data[K_EQUIP_LOCATE], _data[K_EQUIP_COLOR] }));
		mpAttr["attributes"] = _data["attributes"];
		mpAttr["attrCnt"] = _data["attrCnt"];

		foreach (string _key in keys(mpAttr["attributes"])) {
			xilianAttrKeys[_key] = 1;
		}
	}
}

void initBaoshiGradeTable()
{
	staticGradeBaoshiData = ([]);

	foreach (string _type, mapping _data in staticBaoshiData) {
		mapping mpGradeData = getOrSetMapping(staticGradeBaoshiData, _data[K_BAOSHI_TYPE]);
		mpGradeData[_data[K_BAOSHI_GRADE]] = _type;
	}
}

int randomValue(int min, int max)
{
	return min + random(max - min);
}

mapping getRandXilianAttr(int grade, int color, int locate)
{
	mapping mpAttr = getmappingdepth(xilianAttrTable, ({grade, color, locate}));

	if (!mapp(mpAttr)) {
		debug_message("%d, %d, %d, %O, ä¸å­˜åœ¨", grade, color, locate, xilianAttrTable);
		return 0;
	}

	mixed *randArr = rand_x_array(keys(mpAttr["attributes"]), mpAttr["attrCnt"]);

	mapping res = ([]);

	foreach (string attrKey in randArr) {
		res[attrKey] = randomValue(mpAttr["attributes"][attrKey][0], mpAttr["attributes"][attrKey][1]);
	}
	return res;
}

void initEquip(int item)
{
	string type = GetItemSave(item, K_ITEM_TYPE);
	int grade = getEquipGrade(type);
	int color = getEquipColor(type);
	int locate = getEquipLocate(type);

	// è®¾ç½®æ´—ç»ƒå±æ€§
	mapping xilianAttr = getRandXilianAttr(grade, color, locate);

	if (sizeof(xilianAttr)) {
		SetItemSave(item, K_ITEM_XILIAN_ATTR, xilianAttr);
		/*
		foreach (string attrKey, int value in xilianAttr) {
			SetItemSave(item, attrKey, value);
		}
		*/
	}
}

// è·å–è£…å¤‡å±æ€§
mapping getEquipAttribute(int item)
{
	string type = GetItemSave(item, K_ITEM_TYPE);
	mapping res = ([]);

	if (!IS_EQUIP_TYPE(type)) return res;

	int qianghuaCnt = GetItemSave(item, K_ITEM_QIANGHUA);
	int qianghuaVal = getEquipQianghuaValue(type);
	mapping baseAttr = getEquipAttr(type);


	mapping xilianAttr = GetItemSave(item, K_ITEM_XILIAN_ATTR);
	// æ´—ç»ƒå±æ€§
	// TODO:
	if (sizeof(xilianAttr)) {
		foreach (mixed _key, int _val in xilianAttr) {
			if (_val > 0) {
				res[_key] = _val;
			}
		}
	}

	// åŸºç¡€å±æ€§
	foreach (mixed _key, int _val in baseAttr) {
		res[_key] += _val + qianghuaVal * qianghuaCnt;
	}

	// å®çŸ³
	mapping baoshis = GetItemSave(item, K_ITEM_BAOSHI);
	if (sizeof(baoshis)) {
		foreach (string _type in keys(baoshis)) {
			mapping attr = staticBaoshiData[_type][K_BAOSHI_ATTR];
			foreach (mixed _key, float _val in xilianAttr) {
				if (_val > 0) {
					res[_key] += _val;
				}
			}
		}
	}
	return res;
}

mapping getBagEquipAttr(object user, int bagId)
{
	int *items = user->getAllItemsInBag(bagId);
	mapping attr = ([]);

	foreach (int item in items) {
		mapping res = getEquipAttribute(item);
		if (sizeof(res))  {
			foreach (mixed key, int _val in res) {
				attr[key] += _val;
			}
		}
	}
	return attr;
}


// è®¡ç®—æŸèƒŒåŒ…çš„è£…å¤‡å±æ€§
void calcUserEquipAttr(object user, int bagId)
{
	if (!isEquipBag(bagId)) return;

	// è£…å¤‡æ˜¯é‚£ä¸ªä½ç½®çš„
	if (bagId == ITEM_BAG_EQUIP) {
		user->calculateAllAttr();
		user->sendHeroSpeciInfo();
	} else {
		// mapping attr = getBagEquipAttr(user, bagId);
		// æ‰¾åˆ°å¯¹åº”çš„å¬å”¤å…½
		int summonId = "module/summon/util"->findSummonIdByEquipBagId(user, bagId);
		if (summonId) {
			"module/summon/util"->calculateSummon(summonId);
			"module/summon/util"->rpcSummonInfo(user->getId(), summonId);
		}
	}
}



// ç©¿ä¸Šè£…å¤‡
void wieldEquip(object user, int item, int bagId, int locate)
{
	int uid = user->getId();
	string type = GetItemSave(item, K_ITEM_TYPE);

	if (!isEquipBag(bagId)) return;

	if (!IS_EQUIP_TYPE(type)) {
		user->tellTips("è£…å¤‡ç±»å‹å‡ºé”™");
		debug_message("[%d] wield unvalid equip[%s]", uid, type);
		return;
	}
	
	if (getEquipLocate(type) != locate) {
		locate = getEquipLocate(type);
	}

	// locate å³ä¸ºä½ç½®
	int oriItem = user->getItemByPos(bagId, locate);

	if (oriItem) {

		// å…ˆåˆ é™¤ï¼Œä¿è¯ä¸€å®šæœ‰ä½ç½®å¯ä»¥æ”¾ç°åœ¨çš„è£…å¤‡
		user->Removeitem(item);

		user->MoveItem(oriItem, ITEM_BAG_NORMAL);
	}

	user->MoveItem(item, bagId, locate);

	calcUserEquipAttr(user, bagId);
}

// å¸ä¸‹è£…å¤‡
void unwieldEquip(object user, int item, int pos)
{
	// æ˜¯å¦ç‰©å“æ»¡äº†

	int uid = user->getId();
	string type = GetItemSave(item, K_ITEM_TYPE);
	int bagId = GetItemTemp(item, KT_ITEM_BAG);
	int locate = getEquipLocate(type);

	int oriItem = user->getItemByPos(bagId, locate);
	
	if (oriItem != item) {
		debug_message("[%d] unwield item [%d] error", user->getId(), item);
		return;
	}

	user->MoveItem(item, ITEM_BAG_NORMAL, pos);

	calcUserEquipAttr(user, bagId);
}


void sendEquipItemInfo(int uid, int item)
{
	string type = GetItemSave(item, K_ITEM_TYPE);

	int qianghua = GetItemSave(item, K_ITEM_QIANGHUA);

	class equip_value_t *values = ({});

	// TODO:
	/*
	foreach (mixed _key, int _ in xilianAttrKeys) {
		class equip_value_t _value = new(class equip_value_t);
		int _val = GetItemSave(item, _key);
		if (_val > 0) {
			_value->key = _key;
			_value->value = _val;
			values += ({ _value });
		}
	}
	*/

	mapping xilianAttr = GetItemSave(item, K_ITEM_XILIAN_ATTR);

	// æ´—ç»ƒå±æ€§
	if (sizeof(xilianAttr)) {
		foreach (mixed _key, int _val in xilianAttr) {
			class equip_value_t _value = new(class equip_value_t);
			if (_val > 0) {
				_value->key = _key;
				_value->value = _val;
				values += ({ _value });
			}
		}
	}

	string *baoshis = ({});

	mapping baoshiInfo = GetItemSave(item, K_ITEM_BAOSHI);

	if (sizeof(baoshiInfo)) {
		baoshis = keys(baoshiInfo);
	}
	rpc_client_equip_item_info(uid, item, qianghua, values, baoshis);
}

// å‘é€è£…å¤‡å±æ€§
void sendEquipInfo(int uid, int item)
{
	sendEquipItemInfo(uid, item);
	sendXilianInfo(uid, item);
}


// å‘é€è£…å¤‡å±æ€§
void sendEquipDesc(int uid, string type)
{
	int color = getEquipColor(type);
	int locate = getEquipLocate(type);
	int grade = getEquipGrade(type);
	int qianghuaVal = getEquipQianghuaValue(type);
	mapping attr = getEquipAttr(type);

	class equip_value_t *values = ({});

	foreach (mixed _key, mixed _val in attr) {
		class equip_value_t _value = new(class equip_value_t);
		_value->key = _key;
		_value->value = _val;
		values += ({ _value });
	}

	rpc_client_equip_desc(uid, type, grade, qianghuaVal, locate, color, values);
}


#define hasEnoughItem(user, desc) \
	(sizeof(desc) && user->getSameTypeItemAmount(desc[0]) > desc[1])

int hasEnoughCailiao(object user, mapping data)
{
	mixed *lowCailiao = data[K_NEED_L_LEV_CAILIAO];
	mixed *highCailiao = data[K_NEED_H_LEV_CAILIAO];
	mixed *tupus = data[K_NEED_TUPU];
	int cash = data[K_NEED_CASH];

	if (!hasEnoughItem(user, lowCailiao)) {
		user->tellMe("%sææ–™ä¸è¶³!", Import("ITEM_UTIL")->getNameByType(lowCailiao[0]));
		// getText("%s²ÄÁÏ²»×ã!", Import("ITEM_UTIL")->getNameByType(lowCailiao[0]));
		return 0;
	}

	if (!hasEnoughItem(user, highCailiao)) {
		user->tellMe("%sææ–™ä¸è¶³!", Import("ITEM_UTIL")->getNameByType(highCailiao[0]));
		return 0;
	}

	if (!hasEnoughItem(user, tupus)) {
		user->tellMe("%så›¾è°±ä¸è¶³!", Import("ITEM_UTIL")->getNameByType(tupus[0]));
		return 0;
	}

	if (user->hasCash(cash)) {
		user->tellMe("é‡‘é’±ä¸è¶³");
		return 0;
	}

	return 1;
}

void doDeductCailiao(object user, mapping data)
{
	// TODO:
	return ;
}

int getEquipQianghuaCD(object user)
{
	mapping data = user->getEquip();
	if (!data[K_QIANGHUA_CD]) {
		return 0;
	}
	int remain = data[K_QIANGHUA_CD] - time();
	if (remain < 0) return 0;
	return remain;
}

void sendEquipQianghuaCD(object user)
{
	rpc_client_equip_qianghua_cd(user->getId(), getEquipQianghuaCD(user), QIANGHUA_MAX_MIN);
}


void addEquipQianghuaCD(object user, int min)
{
	mapping data = user->getEquip();

	data[K_QIANGHUA_CD] = getEquipQianghuaCD(user) + min * 60;

	sendEquipQianghuaCD(user);
}

void sendEquipQianghuaInfo(object user, int item)
{
	// TODO:
	rpc_client_equip_qianghua_info(user->getId(), item, 0);
}

// å¼ºåŒ–è£…å¤‡
void doQianghuaEquip(object user, int item)
{
	int qianghua = GetItemSave(item, K_ITEM_QIANGHUA);
	int grade = user->getGrade();

	if (grade < qianghua) {
		user->tellMe("è£…å¤‡å·²ç»å¼ºåŒ–åˆ°ç›®å‰æœ€é«˜ç­‰çº§ï¼Œè¯·æå‡äººç‰©ç­‰çº§å†æ¥å¼ºåŒ–ã€‚");
		return;
	}

	if (grade < QIANGHUA_LIMIT_GRADE && (getEquipQianghuaCD(user) >= QIANGHUA_MAX_MIN)) {
		user->tellMe("ä½ æš‚æ—¶æ— æ³•è¿›è¡Œè£…å¤‡å¼ºåŒ–!");
		return;
	}

	string type = GetItemSave(item, K_ITEM_TYPE);
	int color = getEquipColor(type);
	int locate = getEquipLocate(type);
	int cash = "data/equip_qianghua_cash_data"->getQianghuaCash(qianghua + 1, locate, color);

	if (cash && user->hasCash(cash)) {
		user->tellMe("é‡‘é’±ä¸è¶³");
		return;
	}

	int res = user->subCash(cash);
	user->tellMe("ä½ æ¶ˆè€—äº†%dé‡‘é’±", res);

	// TODO: æ¶ˆè€—é‡‘é’±

	SetItemSave(item, K_ITEM_QIANGHUA, qianghua + 1);

	sendEquipInfo(user->getId(), item);

	int bagId = GetItemTemp(item, KT_ITEM_BAG);
	calcUserEquipAttr(user, bagId);

	if (grade < QIANGHUA_LIMIT_GRADE) {
		// å¢åŠ å¼ºåŒ–CD
		addEquipQianghuaCD(user, 5);
	}
}


// è£…å¤‡è¿›é˜¶
void doAdvanceEquip(object user, int item)
{
	string type = GetItemSave(item, K_ITEM_TYPE);

	mapping mpData = getEquipDesc(type);

	if (!sizeof(mpData[K_EQUIP_PRODUCT])) {
		user->tellMe("è¯¥è£…å¤‡ä¸å…è®¸è¿›é˜¶");
		return;
	}

	if (!hasEnoughCailiao(user, mpData)) {
		return;
	}

	// TODO: æ‰£é™¤ææ–™
}


void resetData()
{
	staticEquipData = "data/equip_data.c"->get_data();
	staticXilianData = "data/equip_xilian_data"->get_data();
	staticBaoshiData = "data/baoshi_data"->get_data();
	initXilianAttrTable();
	initBaoshiGradeTable();
}

void loginCheck(object user)
{
	sendEquipQianghuaCD(user);
}

void create()
{
	_log = Import("LOG")->New("equip");
	resetData();
}

// ç©¿ä¸Šè£…å¤‡
void rpc_server_wield_equip(object user, int item, int bagId, int locate)
{
	assert( GetItemTemp(item, KT_ITEM_OWNER) == user->getId() );
	wieldEquip(user, item, bagId, locate);
}

// å¸ä¸‹è£…å¤‡
void rpc_server_unwield_equip(object user, int item, int pos)
{
	assert( GetItemTemp(item, KT_ITEM_OWNER) == user->getId() );
	unwieldEquip(user, item, pos);
}

// å¼ºåŒ–
void rpc_server_equip_qianghua(object user, int item)
{
	assert( GetItemTemp(item, KT_ITEM_OWNER) == user->getId() );
	doQianghuaEquip(user, item);
}


// å¼ºåŒ–req
void rpc_server_equip_qianghua_info_req(object user, int item)
{
	sendEquipQianghuaCD(user);
	sendEquipQianghuaInfo(user, item);
}

// ====================è£…å¤‡æ´—ç»ƒ=================


void doXilianNormal(object user, int item)
{
	string type = GetItemSave(item, K_ITEM_TYPE);
	int grade = getEquipGrade(type);
	int color = getEquipColor(type);
	int locate = getEquipLocate(type);
	int cash = 5;
	int res = 0;
	
	if (cash && user->hasCash(cash)) {
		user->tellMe("é‡‘é’±ä¸è¶³");
		return;
	}

	res = user->subCash(cash);
	user->tellMe("ä½ æ¶ˆè€—äº†%dé‡‘é’±", res);

	// è®¾ç½®æ´—ç»ƒå±æ€§
	mapping xilianAttr = getRandXilianAttr(grade, color, locate);

	debug_message("xilian Attr: %O", xilianAttr);

	if (sizeof(xilianAttr)) {
		SetItemSave(item, K_ITEM_XILIAN_ATTR_REP, xilianAttr);
	}
	sendXilianInfo(user->getId(), item);
}

void doXilianAttrReplace(object user, int item)
{
	mapping attrRep = GetItemSave(item, K_ITEM_XILIAN_ATTR_REP);

	if (sizeof(attrRep)) {
		SetItemSave(item, K_ITEM_XILIAN_ATTR, attrRep);
		SetItemSave(item, K_ITEM_XILIAN_ATTR_REP, ([]));
		// sendXilianInfo(user->getId(), item);
		sendEquipInfo(user->getId(), item);
	}
}

void doXilianAttrDirect(object user, int item)
{
	string type = GetItemSave(item, K_ITEM_TYPE);
	int grade = getEquipGrade(type);
	int color = getEquipColor(type);
	int locate = getEquipLocate(type);
	int cash = 5;
	int res = 0;
	
	res = user->subCash(cash);
	user->tellMe("ä½ æ¶ˆè€—äº†%dé‡‘é’±", res);


	mapping xilianAttr = GetItemSave(item, K_ITEM_XILIAN_ATTR);

	if (!sizeof(xilianAttr)) {
		initEquip(item);
		return;
	}

	// è®¾ç½®æ´—ç»ƒå±æ€§
	mapping attrTable = getmappingdepth(xilianAttrTable, ({grade, color, locate}));
	mapping newAttr = ([]);

	foreach (string key in keys(xilianAttr)) {
		newAttr[key] = randomValue(attrTable["attributes"][key][0], attrTable["attributes"][key][1]);
	}

	SetItemSave(item, K_ITEM_XILIAN_ATTR_REP, newAttr);
	sendXilianInfo(user->getId(), item);
}

void sendXilianInfo(int uid, int item)
{

	mapping mpAttr = GetItemSave(item, K_ITEM_XILIAN_ATTR_REP);

	class equip_value_t *attr = ({});

	if (sizeof(mpAttr)) {
		foreach (mixed _key, int _val in mpAttr) {
			class equip_value_t _value = new(class equip_value_t);
			if (_val > 0) {
				_value->key = _key;
				_value->value = _val;
				attr += ({ _value });
			}
		}
	}

	debug_message("send xilian info : %O, %O", attr, mpAttr);

	// TODO: æ™®é€šæ´—ç»ƒé‡‘é’±ï¼Œå®šå‘æ´—ç»ƒé‡‘é’±
	rpc_client_equip_xilian_info(uid, item, 1, 1, attr);
}

// ========================================================
// å®çŸ³ç›¸å…³

int hasSameTypeBaoshi(mapping baoshiInfo, string type)
{
	if (!sizeof(baoshiInfo)) return 0;

	mapping types = ([]);
	foreach (string _t in keys(baoshiInfo)) {
		types[staticBaoshiData[_t][K_BAOSHI_TYPE]] += 1;
	}
	
	return (!undefinedp(types[type]));
}

void doEquipAddBaoshi(object user, int equipItem, int baoshiItem)
{
	int uid = user->getId();
	assert( GetItemTemp(equipItem, KT_ITEM_OWNER) == uid );
	assert( GetItemTemp(baoshiItem, KT_ITEM_OWNER) == uid );

	mapping baoshiInfo = GetItemSave(equipItem, K_ITEM_BAOSHI);

	// TODO: è£…å¤‡å¤Ÿä¸å¤Ÿä½ç½®

	string type = GetItemSave(baoshiItem, K_ITEM_TYPE);

	if (hasSameTypeBaoshi(baoshiInfo, type)) {
		user->tellMe("è¿™æŠŠæ­¦å™¨å·²ç»é•¶æœ‰åŒç±»å®çŸ³!");
		return;
	}

	if (mapp(baoshiInfo)) {
		baoshiInfo[type] = 1;
	}
	user->Removeitem(baoshiItem);

	int bagId = GetItemTemp(equipItem, KT_ITEM_BAG);
	calcUserEquipAttr(user, bagId);
}

string getBaoshiUpGradeType(string type)
{
	int grade = staticBaoshiData[type][K_BAOSHI_GRADE];

	string upGradeType = staticGradeBaoshiData[grade + 1];

	if (undefinedp(upGradeType)) {
		return "";
	}
	return upGradeType;
}

void doUpGradeEquipBaoshi(object user, int equipItem, string type)
{
	int uid = user->getId();

	assert( GetItemTemp(equipItem, KT_ITEM_OWNER) == uid );

	mapping baoshiInfo = GetItemSave(equipItem, K_ITEM_BAOSHI);

	assert(!undefinedp(baoshiInfo[type]));

	// æ‰¾åˆ°åŒç±»çš„ç‰©å“
	if (user->getSameTypeItemAmount(type, ITEM_BAG_BAOSHI) <= 0) {
		user->tellMe("ä½ çš„å®çŸ³ä¸è¶³!");
		return;
	}

	string upGradeType = getBaoshiUpGradeType(type);

	user->delSameTypeItemAmount(type, 1, ITEM_BAG_BAOSHI);

	map_delete(baoshiInfo, type);
	baoshiInfo[upGradeType] = 1;

	int bagId = GetItemTemp(equipItem, KT_ITEM_BAG);
	calcUserEquipAttr(user, bagId);
	_log->Log("[%d] equip upgrade baoshi %s->%s", user->getId(), type, upGradeType);
}

void doEquipRemoveBaoshi(object user, int equipItem, string baoshiType)
{
	int uid = user->getId();
	assert( GetItemTemp(equipItem, KT_ITEM_OWNER) == uid );

	mapping baoshiInfo = GetItemSave(equipItem, K_ITEM_BAOSHI);

	if (mapp(baoshiInfo) && !undefinedp(baoshiInfo[baoshiType])) {
		 if (Import("ITEM_UTIL")->addNewItem(user, baoshiType, 1) > 0) {
			map_delete(baoshiInfo, baoshiType);
			// _log->Log("[%d] equip remove baoshi %s", uid, baoshiType);
		 } else {
			 user->tellMe("ä½ çš„ç‰©å“æ æ»¡äº†ï¼Œæ— æ³•å¸ä¸‹è£…å¤‡!");
			 return;
		 }
	}

	int bagId = GetItemTemp(equipItem, KT_ITEM_BAG);
	calcUserEquipAttr(user, bagId);
}

void doUpGradeBaoshi(object user, int itemid)
{
	int uid = user->getId();

	assert( GetItemTemp(itemid, KT_ITEM_OWNER) == uid );
	string type = GetItemSave(itemid, K_ITEM_TYPE);

	string upGradeType = getBaoshiUpGradeType(type);

	if (!sizeof(upGradeType)) {
		user->tellMe("è¿™é¢—å®çŸ³å·²ç»æ˜¯æœ€é«˜çº§åˆ«äº†!");
		return;
	}

	if (user->getSameTypeItemAmount(type, ITEM_BAG_BAOSHI) < 2) {
		user->tellMe("ä½ çš„å®çŸ³ä¸è¶³æ— æ³•å‡çº§!");
		return;
	}

	if (Import("ITEM_UTIL")->addNewItem(user, upGradeType, 1) > 0) {
		user->delSameTypeItemAmount(type, 2, ITEM_BAG_BAOSHI);
		user->tellMe("å‡çº§æˆåŠŸ!");
		_log->Log("[%d] upgrade baoshi %s->%d", user->getId(), type, upGradeType);
	}
}

// ========================================================
// æ™®é€šæ´—ç»ƒ
// é‡æ–°éšæœºç”Ÿæˆ
void rpc_server_equip_xilian_normal(object user, int item)
{
	doXilianNormal(user, item);
}

// å®šå‘æ´—ç»ƒ
// ä¸æ”¹å±æ€§
void rpc_server_equip_xilian_direct(object user, int item)
{
	doXilianAttrDirect(user, item);
}

// æ›¿æ¢å±æ€§
void rpc_server_equip_xilian_replace_attr(object user, int item)
{
	doXilianAttrReplace(user, item);
}

// åµŒä¸Šå®çŸ³
void rpc_server_equip_add_baoshi(object user, int equipItem, int baoshiItem)
{
	doEquipAddBaoshi(user, equipItem, baoshiItem);
}

// å¸ä¸‹å®çŸ³
void rpc_server_equip_remove_baoshi(object user, int equipItem, string baoshiType)
{
	doEquipRemoveBaoshi(user, equipItem, baoshiType);
}

// åˆå¹¶å®çŸ³
void rpc_server_equip_merge_baoshi(object user, int baoshiItem)
{
	doUpGradeBaoshi(user, baoshiItem);
}

void rpc_server_baoshi_upgrade(object user, int itemid)
{
	doUpGradeBaoshi(user, itemid);
}
